interface SplatterConfig {
    splatId?: string;
    /** Enterprise tier only */
    customUrl?: string;
}
type ClientPoint = [number, number];
/**
 * Splatter is a streaming LOD (level-of-detail) renderer for large Gaussian splatting datasets
 * (see https://splatter.app).
 *
 * This class provides a Three.js-compatible interface for rendering splat datasets hosted
 * either at splatter.app's CDN (Business tier) or at a custom URL (Enterprise tier).
 *
 * Splatter requires a WebGL2 context to render the splat scene. See example usage and Three.js
 * initialization at https://github.com/splatter-app/three-demo
 *
 * Due to the nature of the Gaussian splatting method, the splats are rendered as a special
 * (translucent) render pass after the Three.js scene is rendered. The Three.js scene is
 * assumed to be opaque, with a valid depth buffer, and the splats are composited over it.
 *
 */
export declare class Splatter {
    /**
     * Initialize the renderer with a WebGL2 context and configuration.
     * The configuration must include one of:
     *   - `splatId` (Business tier)
     *   - `customUrl` (Enterprise tier only)
     */
    constructor(context: WebGL2RenderingContext, config: SplatterConfig);
    /**
     * The total number of Gaussians in the scene, including all coarse LOD Gaussians (these typically
     * comprise 35-40% extra Gaussians on top of the original Gaussians). This is a read-only property that
     * does not reflect the number of Gaussians actually loaded (see the 'loaded' event for that).
     */
    get totalSize(): number;
    /**
     * Renders the splat scene into the currently bound framebuffer, using the given camera.
     * This is effectively a translucent render pass, where each splat is composited (blended) over
     * the existing framebuffer content, with depth testing.
     *
     * The Three.js scene must be opaque, with a valid depth buffer. Any translucent content will
     * not get composited correctly with the splat scene.
     *
     * The method also uses the camera position and framebuffer resolution to schedule streaming of LOD
     * scene content. The optional `target` parameter can be used to prioritize streaming near a specific
     * point in world space other than the camera position, e.g., the orbit control center.
     *
     * @param {THREE.Camera} camera Current Three.js camera, or a compatible camera-like object. Only the
     * `matrixWorldInverse` and `projectionMatrix` properties are used.
     * @param {THREE.Vector3 | null} target Optional target point in world space to prioritize streaming at.
     */
    render(camera: THREE.Camera, target?: THREE.Vector3 | null): void;
    /**
     * @returns the 3D point that projects to the given client coordinates of the canvas, or null if no
     * splat is rendered there. This method is used for hit-testing, i.e. finding the 3D position of
     * a splat under the mouse cursor. Note that only splats are tested, not the Three.js scene.
     *
     * Internally, a special depth frame is rendered, where the approximate scene depth is used to find the
     * 3D world position corresponding to the client coordinates and current camera projection.
     *
     * @param camera - The camera that was used to render the current frame.
     * @param clientPoints - A single point, or an array of points to query multiple client positions.
     * @param options - Optional parameters:
     * @param options.alphaThreshold - Individual pixels below this opacity are skipped when rendering the
     *    depth frame. Lower value leads to more hits but also more noise. Default is 0.25.
     *
     * Example:
     *   let worldPt = splatter.hitTest(camera, [event.clientX, event.clientY])
     *   if (worldPt) {
     *      console.log(`Clicked world coordinates: (${worldPt.x}, ${worldPt.y}, ${worldPt.z})`);
     *   }
     */
    hitTest(camera: THREE.Camera, clientPoints: ClientPoint | ClientPoint[], options?: {
        alphaThreshold?: number;
    }): THREE.Vector3 | null | (THREE.Vector3 | null)[];
    /**
     * Set subsampling factor for rendering the splat scene. This allows rendering at lower resolution
     * than the native device resolution, improving performance (especially on mobile devices).
     *
     * Rendering at a lower resolution than the Three.js canvas resolution will however result in lower
     * quality compositing with the Three.js scene, as the splat scene will first be rendered to a lower
     * resolution framebuffer, and then composited with the full resolution frame using only approximate
     * depth information. Occlusion of the Three.js scene will thus also be approximate.
     *
     * @param pixelRatio - subsampling factor, e.g. 2 to render at half resolution. You can also use
     * window.devicePixelRatio to render at CSS resolution.
     */
    setPixelRatio(pixelRatio: number): void;
    /**
     * Set a transform to apply to the Gaussians (before the view and projection matrices are applied).
     */
    setTransform(transform: THREE.Matrix4): void;
    /**
     * Inject GLSL commands to the splat vertex shader code. This allows manipulating the color, opacity,
     * scale and rotation of the Gaussians before they are rendered.
     *
     * @param effect A sequence of semicolon-separated GLSL commands to be injected into the vertex shader.
     *    The commands may alter these variables:
     *    - `vec3 color`: the RGB color of the Gaussian.
     *    - `float opacity`: the opacity of the Gaussian, in range [0, 1].
     *    - `vec3 scale`: the (x,y,z) size of the Gaussian, in world units.
     *    - `vec4 quat`: the rotation of the Gaussian, represented as a quaternion (x,y,z,w).
     *    These variables already contain the unmodified values. Not all variables need to be modified.
     *    In addition to the read/write variables color, opacity, scale and quat, the following are available
     *    as read-only variables:
     *    - `vec3 position`: the center of the Gaussian in world space.
     *    - custom uniform variables to pass additional data, registered once with `addUniform()` and
     *      set per-frame with `setUniform()`.
     *
     * Example:
     *    splatter.setShaderEffect(`
     *       float gray = dot(color, vec3(0.299, 0.587, 0.114));
     *       color = vec3(gray);
     *    `);
     */
    setShaderEffect(effect: string): void;
    /**
     * Register a uniform variable to be used in the shader effect.
     *
     * @param type GLSL type name, e.g. 'float', 'vec3', 'mat4', etc.
     * @param name Name of the uniform shader variable, as referenced in the shader effect.
     */
    addUniform(type: string, name: string): void;
    /**
     * Set the value of a uniform variable. The value will be available to the shader effect code
     * as a constant during the `render()` call.
     *
     * @param name Name of the uniform variable, as registered with `addUniform()`.
     * @param value Value to set the uniform to. This can be a single number, an array of numbers,
     *      or a THREE vector/matrix object.
     */
    setUniform(name: string, value: number | number[] | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Matrix2 | THREE.Matrix3 | THREE.Matrix4): void;
    /**
     * Set a custom clipping test to be injected into the GLSL vertex shader. In addition to the standard
     * camera frustum culling, custom statements can be defined to discard Gaussians based on their
     * world position and radius (safety margin based on the largest scale of the Gaussian).
     *
     * @param code Body of a GLSL function that takes a `vec3 position` and a `float radius` as parameters,
     *    and returns a boolean value indicating whether the Gaussian should be skipped when rendering.
     *    Any GLSL code can be used, but the function must return a boolean value. Uniforms previously
     *    registered with `addUniform()` can also be used in the code.
     *
     * Example:
     *    splatter.setClipTest(`
     *       if (length(position) > 10.0) { return false; }  // clip Gaussians outside a sphere of radius 10
     *       return true;  // render all other Gaussians (this line can be omitted)
     *    `);
     */
    setClipTest(code: string): void;
    /**
     * Register a callback function for the 'update' event.
     * The callback is invoked when the splat scene needs redrawing, e.g. when new content is fetched.
     * The event is useful for on-demand rendering.
     * @param event Event name: 'update'.
     */
    addEventListener(event: 'update', callback: () => void): void;
    /**
     * Register a callback function for the 'loaded' event.
     * The callback is invoked with the total number of Gaussians streamed in so far ('totalLoaded')
     * and the number of currently displayed Guassians ('numDisplayed').
     * @param event Event name: 'loaded'.
     * @param callback Called with 'totalLoaded' and 'numDisplayed'.
     */
    addEventListener(event: 'loaded', callback: (totalLoaded: number, numDisplayed: number) => void): void;
    /**
     * Register a callback function for the 'error' event.
     * @param event Event name: 'error'.
     * @param callback Called with an error message.
     */
    addEventListener(event: 'error', callback: (message: string) => void): void;
    /**
     * (Enterprise tier only)
     * Register a callback function for the 'blockFetched' event.
     * The callback is invoked when a new streaming block is downloaded. The user has the
     * opportunity to modify (e.g. decrypt) the block in-place, before it is processed.
     * @param event Event name: 'blockFetched'.
     * @param callback Called with a buffer to modify in-place.
     */
    addEventListener(event: 'blockFetched', callback: (block: ArrayBuffer) => void): void;
}
export {};
